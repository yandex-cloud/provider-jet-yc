/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DirectResponseActionObservation struct {
}

type DirectResponseActionParameters struct {

	// +kubebuilder:validation:Optional
	Body *string `json:"body,omitempty" tf:"body,omitempty"`

	// +kubebuilder:validation:Optional
	Status *float64 `json:"status,omitempty" tf:"status,omitempty"`
}

type FqmnObservation struct {
}

type FqmnParameters struct {

	// +kubebuilder:validation:Optional
	Exact *string `json:"exact,omitempty" tf:"exact,omitempty"`

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type GRPCMatchObservation struct {
}

type GRPCMatchParameters struct {

	// +kubebuilder:validation:Optional
	Fqmn []FqmnParameters `json:"fqmn,omitempty" tf:"fqmn,omitempty"`
}

type GRPCRouteActionObservation struct {
}

type GRPCRouteActionParameters struct {

	// +kubebuilder:validation:Optional
	AutoHostRewrite *bool `json:"autoHostRewrite,omitempty" tf:"auto_host_rewrite,omitempty"`

	// +crossplane:generate:reference:type=BackendGroup
	// +kubebuilder:validation:Optional
	BackendGroupID *string `json:"backendGroupId,omitempty" tf:"backend_group_id,omitempty"`

	// Reference to a BackendGroup to populate backendGroupId.
	// +kubebuilder:validation:Optional
	BackendGroupIDRef *v1.Reference `json:"backendGroupIdRef,omitempty" tf:"-"`

	// Selector for a BackendGroup to populate backendGroupId.
	// +kubebuilder:validation:Optional
	BackendGroupIDSelector *v1.Selector `json:"backendGroupIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	HostRewrite *string `json:"hostRewrite,omitempty" tf:"host_rewrite,omitempty"`

	// +kubebuilder:validation:Optional
	IdleTimeout *string `json:"idleTimeout,omitempty" tf:"idle_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	MaxTimeout *string `json:"maxTimeout,omitempty" tf:"max_timeout,omitempty"`
}

type GRPCRouteObservation struct {
}

type GRPCRouteParameters struct {

	// +kubebuilder:validation:Optional
	GRPCMatch []GRPCMatchParameters `json:"grpcMatch,omitempty" tf:"grpc_match,omitempty"`

	// +kubebuilder:validation:Optional
	GRPCRouteAction []GRPCRouteActionParameters `json:"grpcRouteAction,omitempty" tf:"grpc_route_action,omitempty"`

	// +kubebuilder:validation:Optional
	GRPCStatusResponseAction []GRPCStatusResponseActionParameters `json:"grpcStatusResponseAction,omitempty" tf:"grpc_status_response_action,omitempty"`
}

type GRPCStatusResponseActionObservation struct {
}

type GRPCStatusResponseActionParameters struct {

	// +kubebuilder:validation:Optional
	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type HTTPMatchObservation struct {
}

type HTTPMatchParameters struct {

	// +kubebuilder:validation:Optional
	HTTPMethod []*string `json:"httpMethod,omitempty" tf:"http_method,omitempty"`

	// +kubebuilder:validation:Optional
	Path []PathParameters `json:"path,omitempty" tf:"path,omitempty"`
}

type HTTPRouteActionObservation struct {
}

type HTTPRouteActionParameters struct {

	// +kubebuilder:validation:Optional
	AutoHostRewrite *bool `json:"autoHostRewrite,omitempty" tf:"auto_host_rewrite,omitempty"`

	// +crossplane:generate:reference:type=BackendGroup
	// +kubebuilder:validation:Optional
	BackendGroupID *string `json:"backendGroupId,omitempty" tf:"backend_group_id,omitempty"`

	// Reference to a BackendGroup to populate backendGroupId.
	// +kubebuilder:validation:Optional
	BackendGroupIDRef *v1.Reference `json:"backendGroupIdRef,omitempty" tf:"-"`

	// Selector for a BackendGroup to populate backendGroupId.
	// +kubebuilder:validation:Optional
	BackendGroupIDSelector *v1.Selector `json:"backendGroupIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	HostRewrite *string `json:"hostRewrite,omitempty" tf:"host_rewrite,omitempty"`

	// +kubebuilder:validation:Optional
	IdleTimeout *string `json:"idleTimeout,omitempty" tf:"idle_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixRewrite *string `json:"prefixRewrite,omitempty" tf:"prefix_rewrite,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout *string `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// +kubebuilder:validation:Optional
	UpgradeTypes []*string `json:"upgradeTypes,omitempty" tf:"upgrade_types,omitempty"`
}

type HTTPRouteObservation struct {
}

type HTTPRouteParameters struct {

	// +kubebuilder:validation:Optional
	DirectResponseAction []DirectResponseActionParameters `json:"directResponseAction,omitempty" tf:"direct_response_action,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPMatch []HTTPMatchParameters `json:"httpMatch,omitempty" tf:"http_match,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPRouteAction []HTTPRouteActionParameters `json:"httpRouteAction,omitempty" tf:"http_route_action,omitempty"`

	// +kubebuilder:validation:Optional
	RedirectAction []RedirectActionParameters `json:"redirectAction,omitempty" tf:"redirect_action,omitempty"`
}

type ModifyRequestHeadersObservation struct {
}

type ModifyRequestHeadersParameters struct {

	// +kubebuilder:validation:Optional
	Append *string `json:"append,omitempty" tf:"append,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Remove *bool `json:"remove,omitempty" tf:"remove,omitempty"`

	// +kubebuilder:validation:Optional
	Replace *string `json:"replace,omitempty" tf:"replace,omitempty"`
}

type ModifyResponseHeadersObservation struct {
}

type ModifyResponseHeadersParameters struct {

	// +kubebuilder:validation:Optional
	Append *string `json:"append,omitempty" tf:"append,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Remove *bool `json:"remove,omitempty" tf:"remove,omitempty"`

	// +kubebuilder:validation:Optional
	Replace *string `json:"replace,omitempty" tf:"replace,omitempty"`
}

type PathObservation struct {
}

type PathParameters struct {

	// +kubebuilder:validation:Optional
	Exact *string `json:"exact,omitempty" tf:"exact,omitempty"`

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type RedirectActionObservation struct {
}

type RedirectActionParameters struct {

	// +kubebuilder:validation:Optional
	RemoveQuery *bool `json:"removeQuery,omitempty" tf:"remove_query,omitempty"`

	// +kubebuilder:validation:Optional
	ReplaceHost *string `json:"replaceHost,omitempty" tf:"replace_host,omitempty"`

	// +kubebuilder:validation:Optional
	ReplacePath *string `json:"replacePath,omitempty" tf:"replace_path,omitempty"`

	// +kubebuilder:validation:Optional
	ReplacePort *float64 `json:"replacePort,omitempty" tf:"replace_port,omitempty"`

	// +kubebuilder:validation:Optional
	ReplacePrefix *string `json:"replacePrefix,omitempty" tf:"replace_prefix,omitempty"`

	// +kubebuilder:validation:Optional
	ReplaceScheme *string `json:"replaceScheme,omitempty" tf:"replace_scheme,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseCode *string `json:"responseCode,omitempty" tf:"response_code,omitempty"`
}

type RouteObservation struct {
}

type RouteParameters struct {

	// +kubebuilder:validation:Optional
	GRPCRoute []GRPCRouteParameters `json:"grpcRoute,omitempty" tf:"grpc_route,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPRoute []HTTPRouteParameters `json:"httpRoute,omitempty" tf:"http_route,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type VirtualHostObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type VirtualHostParameters struct {

	// +kubebuilder:validation:Optional
	Authority []*string `json:"authority,omitempty" tf:"authority,omitempty"`

	// +crossplane:generate:reference:type=HTTPRouter
	// +kubebuilder:validation:Optional
	HTTPRouterID *string `json:"httpRouterId,omitempty" tf:"http_router_id,omitempty"`

	// Reference to a HTTPRouter to populate httpRouterId.
	// +kubebuilder:validation:Optional
	HTTPRouterIDRef *v1.Reference `json:"httpRouterIdRef,omitempty" tf:"-"`

	// Selector for a HTTPRouter to populate httpRouterId.
	// +kubebuilder:validation:Optional
	HTTPRouterIDSelector *v1.Selector `json:"httpRouterIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ModifyRequestHeaders []ModifyRequestHeadersParameters `json:"modifyRequestHeaders,omitempty" tf:"modify_request_headers,omitempty"`

	// +kubebuilder:validation:Optional
	ModifyResponseHeaders []ModifyResponseHeadersParameters `json:"modifyResponseHeaders,omitempty" tf:"modify_response_headers,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Route []RouteParameters `json:"route,omitempty" tf:"route,omitempty"`
}

// VirtualHostSpec defines the desired state of VirtualHost
type VirtualHostSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     VirtualHostParameters `json:"forProvider"`
}

// VirtualHostStatus defines the observed state of VirtualHost.
type VirtualHostStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        VirtualHostObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// VirtualHost is the Schema for the VirtualHosts API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloud}
type VirtualHost struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualHostSpec   `json:"spec"`
	Status            VirtualHostStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// VirtualHostList contains a list of VirtualHosts
type VirtualHostList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualHost `json:"items"`
}

// Repository type metadata.
var (
	VirtualHost_Kind             = "VirtualHost"
	VirtualHost_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: VirtualHost_Kind}.String()
	VirtualHost_KindAPIVersion   = VirtualHost_Kind + "." + CRDGroupVersion.String()
	VirtualHost_GroupVersionKind = CRDGroupVersion.WithKind(VirtualHost_Kind)
)

func init() {
	SchemeBuilder.Register(&VirtualHost{}, &VirtualHostList{})
}
