/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BackendGroupObservation struct {
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type BackendGroupParameters struct {

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +crossplane:generate:reference:type=github.com/yandex-cloud/provider-jet-yc/apis/resourcemanager/v1alpha1.Folder
	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Reference to a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

	// Selector for a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	GRPCBackend []GRPCBackendParameters `json:"grpcBackend,omitempty" tf:"grpc_backend,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPBackend []HTTPBackendParameters `json:"httpBackend,omitempty" tf:"http_backend,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	SessionAffinity []SessionAffinityParameters `json:"sessionAffinity,omitempty" tf:"session_affinity,omitempty"`

	// +kubebuilder:validation:Optional
	StreamBackend []StreamBackendParameters `json:"streamBackend,omitempty" tf:"stream_backend,omitempty"`
}

type ConnectionObservation struct {
}

type ConnectionParameters struct {

	// Use source IP address
	// +kubebuilder:validation:Optional
	SourceIP *bool `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type CookieObservation struct {
}

type CookieParameters struct {

	// Name of the HTTP cookie
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// TTL for the cookie (if not set, session cookie will be used)
	// +kubebuilder:validation:Optional
	TTL *string `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type GRPCBackendObservation struct {
}

type GRPCBackendParameters struct {

	// +kubebuilder:validation:Optional
	Healthcheck []HealthcheckParameters `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancingConfig []LoadBalancingConfigParameters `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	TLS []TLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// +crossplane:generate:reference:type=TargetGroup
	// +kubebuilder:validation:Optional
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// References to TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsRefs []v1.Reference `json:"targetGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsSelector *v1.Selector `json:"targetGroupIdsSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type GRPCHealthcheckObservation struct {
}

type GRPCHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type HTTPBackendHealthcheckObservation struct {
}

type HTTPBackendHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	GRPCHealthcheck []HealthcheckGRPCHealthcheckParameters `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPHealthcheck []HealthcheckHTTPHealthcheckParameters `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// +kubebuilder:validation:Optional
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// +kubebuilder:validation:Optional
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// +kubebuilder:validation:Required
	Interval *string `json:"interval" tf:"interval,omitempty"`

	// +kubebuilder:validation:Optional
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// +kubebuilder:validation:Optional
	StreamHealthcheck []HealthcheckStreamHealthcheckParameters `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// +kubebuilder:validation:Required
	Timeout *string `json:"timeout" tf:"timeout,omitempty"`

	// +kubebuilder:validation:Optional
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type HTTPBackendLoadBalancingConfigObservation struct {
}

type HTTPBackendLoadBalancingConfigParameters struct {

	// +kubebuilder:validation:Optional
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// +kubebuilder:validation:Optional
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// +kubebuilder:validation:Optional
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type HTTPBackendObservation struct {
}

type HTTPBackendParameters struct {

	// +kubebuilder:validation:Optional
	Healthcheck []HTTPBackendHealthcheckParameters `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// +kubebuilder:validation:Optional
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancingConfig []HTTPBackendLoadBalancingConfigParameters `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	StorageBucket *string `json:"storageBucket,omitempty" tf:"storage_bucket,omitempty"`

	// +kubebuilder:validation:Optional
	TLS []HTTPBackendTLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// +crossplane:generate:reference:type=TargetGroup
	// +kubebuilder:validation:Optional
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// References to TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsRefs []v1.Reference `json:"targetGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsSelector *v1.Selector `json:"targetGroupIdsSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type HTTPBackendTLSObservation struct {
}

type HTTPBackendTLSParameters struct {

	// +kubebuilder:validation:Optional
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	// +kubebuilder:validation:Optional
	ValidationContext []TLSValidationContextParameters `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type HTTPHealthcheckObservation struct {
}

type HTTPHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`
}

type HeaderObservation struct {
}

type HeaderParameters struct {

	// The name of the request header that will be used
	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`
}

type HealthcheckGRPCHealthcheckObservation struct {
}

type HealthcheckGRPCHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type HealthcheckHTTPHealthcheckObservation struct {
}

type HealthcheckHTTPHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`
}

type HealthcheckObservation struct {
}

type HealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	GRPCHealthcheck []GRPCHealthcheckParameters `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPHealthcheck []HTTPHealthcheckParameters `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// +kubebuilder:validation:Optional
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// +kubebuilder:validation:Optional
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// +kubebuilder:validation:Required
	Interval *string `json:"interval" tf:"interval,omitempty"`

	// +kubebuilder:validation:Optional
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// +kubebuilder:validation:Optional
	StreamHealthcheck []StreamHealthcheckParameters `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// +kubebuilder:validation:Required
	Timeout *string `json:"timeout" tf:"timeout,omitempty"`

	// +kubebuilder:validation:Optional
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type HealthcheckStreamHealthcheckObservation struct {
}

type HealthcheckStreamHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// +kubebuilder:validation:Optional
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type LoadBalancingConfigObservation struct {
}

type LoadBalancingConfigParameters struct {

	// +kubebuilder:validation:Optional
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// +kubebuilder:validation:Optional
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// +kubebuilder:validation:Optional
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type SessionAffinityObservation struct {
}

type SessionAffinityParameters struct {

	// IP address affinity
	// +kubebuilder:validation:Optional
	Connection []ConnectionParameters `json:"connection,omitempty" tf:"connection,omitempty"`

	// Cookie affinity
	// +kubebuilder:validation:Optional
	Cookie []CookieParameters `json:"cookie,omitempty" tf:"cookie,omitempty"`

	// Request header affinity
	// +kubebuilder:validation:Optional
	Header []HeaderParameters `json:"header,omitempty" tf:"header,omitempty"`
}

type StreamBackendHealthcheckGRPCHealthcheckObservation struct {
}

type StreamBackendHealthcheckGRPCHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type StreamBackendHealthcheckHTTPHealthcheckObservation struct {
}

type StreamBackendHealthcheckHTTPHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	Http2 *bool `json:"http2,omitempty" tf:"http2,omitempty"`

	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`
}

type StreamBackendHealthcheckObservation struct {
}

type StreamBackendHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	GRPCHealthcheck []StreamBackendHealthcheckGRPCHealthcheckParameters `json:"grpcHealthcheck,omitempty" tf:"grpc_healthcheck,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPHealthcheck []StreamBackendHealthcheckHTTPHealthcheckParameters `json:"httpHealthcheck,omitempty" tf:"http_healthcheck,omitempty"`

	// +kubebuilder:validation:Optional
	HealthcheckPort *float64 `json:"healthcheckPort,omitempty" tf:"healthcheck_port,omitempty"`

	// +kubebuilder:validation:Optional
	HealthyThreshold *float64 `json:"healthyThreshold,omitempty" tf:"healthy_threshold,omitempty"`

	// +kubebuilder:validation:Required
	Interval *string `json:"interval" tf:"interval,omitempty"`

	// +kubebuilder:validation:Optional
	IntervalJitterPercent *float64 `json:"intervalJitterPercent,omitempty" tf:"interval_jitter_percent,omitempty"`

	// +kubebuilder:validation:Optional
	StreamHealthcheck []StreamBackendHealthcheckStreamHealthcheckParameters `json:"streamHealthcheck,omitempty" tf:"stream_healthcheck,omitempty"`

	// +kubebuilder:validation:Required
	Timeout *string `json:"timeout" tf:"timeout,omitempty"`

	// +kubebuilder:validation:Optional
	UnhealthyThreshold *float64 `json:"unhealthyThreshold,omitempty" tf:"unhealthy_threshold,omitempty"`
}

type StreamBackendHealthcheckStreamHealthcheckObservation struct {
}

type StreamBackendHealthcheckStreamHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// +kubebuilder:validation:Optional
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type StreamBackendLoadBalancingConfigObservation struct {
}

type StreamBackendLoadBalancingConfigParameters struct {

	// +kubebuilder:validation:Optional
	LocalityAwareRoutingPercent *float64 `json:"localityAwareRoutingPercent,omitempty" tf:"locality_aware_routing_percent,omitempty"`

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// +kubebuilder:validation:Optional
	PanicThreshold *float64 `json:"panicThreshold,omitempty" tf:"panic_threshold,omitempty"`

	// +kubebuilder:validation:Optional
	StrictLocality *bool `json:"strictLocality,omitempty" tf:"strict_locality,omitempty"`
}

type StreamBackendObservation struct {
}

type StreamBackendParameters struct {

	// +kubebuilder:validation:Optional
	EnableProxyProtocol *bool `json:"enableProxyProtocol,omitempty" tf:"enable_proxy_protocol,omitempty"`

	// +kubebuilder:validation:Optional
	Healthcheck []StreamBackendHealthcheckParameters `json:"healthcheck,omitempty" tf:"healthcheck,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancingConfig []StreamBackendLoadBalancingConfigParameters `json:"loadBalancingConfig,omitempty" tf:"load_balancing_config,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	TLS []StreamBackendTLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// +crossplane:generate:reference:type=TargetGroup
	// +kubebuilder:validation:Optional
	TargetGroupIds []*string `json:"targetGroupIds,omitempty" tf:"target_group_ids,omitempty"`

	// References to TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsRefs []v1.Reference `json:"targetGroupIdsRefs,omitempty" tf:"-"`

	// Selector for a list of TargetGroup to populate targetGroupIds.
	// +kubebuilder:validation:Optional
	TargetGroupIdsSelector *v1.Selector `json:"targetGroupIdsSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type StreamBackendTLSObservation struct {
}

type StreamBackendTLSParameters struct {

	// +kubebuilder:validation:Optional
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	// +kubebuilder:validation:Optional
	ValidationContext []StreamBackendTLSValidationContextParameters `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type StreamBackendTLSValidationContextObservation struct {
}

type StreamBackendTLSValidationContextParameters struct {

	// +kubebuilder:validation:Optional
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

type StreamHealthcheckObservation struct {
}

type StreamHealthcheckParameters struct {

	// +kubebuilder:validation:Optional
	Receive *string `json:"receive,omitempty" tf:"receive,omitempty"`

	// +kubebuilder:validation:Optional
	Send *string `json:"send,omitempty" tf:"send,omitempty"`
}

type TLSObservation struct {
}

type TLSParameters struct {

	// +kubebuilder:validation:Optional
	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`

	// +kubebuilder:validation:Optional
	ValidationContext []ValidationContextParameters `json:"validationContext,omitempty" tf:"validation_context,omitempty"`
}

type TLSValidationContextObservation struct {
}

type TLSValidationContextParameters struct {

	// +kubebuilder:validation:Optional
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

type ValidationContextObservation struct {
}

type ValidationContextParameters struct {

	// +kubebuilder:validation:Optional
	TrustedCABytes *string `json:"trustedCaBytes,omitempty" tf:"trusted_ca_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	TrustedCAID *string `json:"trustedCaId,omitempty" tf:"trusted_ca_id,omitempty"`
}

// BackendGroupSpec defines the desired state of BackendGroup
type BackendGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     BackendGroupParameters `json:"forProvider"`
}

// BackendGroupStatus defines the observed state of BackendGroup.
type BackendGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        BackendGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// BackendGroup is the Schema for the BackendGroups API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloud}
type BackendGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BackendGroupSpec   `json:"spec"`
	Status            BackendGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// BackendGroupList contains a list of BackendGroups
type BackendGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BackendGroup `json:"items"`
}

// Repository type metadata.
var (
	BackendGroup_Kind             = "BackendGroup"
	BackendGroup_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: BackendGroup_Kind}.String()
	BackendGroup_KindAPIVersion   = BackendGroup_Kind + "." + CRDGroupVersion.String()
	BackendGroup_GroupVersionKind = CRDGroupVersion.WithKind(BackendGroup_Kind)
)

func init() {
	SchemeBuilder.Register(&BackendGroup{}, &BackendGroupList{})
}
